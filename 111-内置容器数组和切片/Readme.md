# 一、数组的用法：

## （一）、概念：

1. 数组是具有相同类型的一组长度固定的数据序列，这种类型可以是任意的基本数据类型或符合数据类型及自定义数据类型；
2. 数组元素可以根据索引下标（位置）来读取或修改元素数据，索引从0开始，数组下标的取值范围是从0开始，到长度减1；
3. 数组一旦定义长度后，大小不能更改；

## （二）、语法：

1、声明数组：

需要指定**元素类型**和**元素个数**，语法格式如下：

- var 变量名 [数组长度]数据类型
- 数组长度必须是整型且大于0
- 未初始化的数组不是nil，也就是说没有空数组（与切片slice不同），而是一堆0；

2、初始化数组：

- var nums = [5]int{1,2,3,4,5}，其中{}中的元素个数不能大于[]中的数字；
- 如果忽略[]中的数字，不设置数组的大小，Go语言会根据元素的个数来设置数组的大小，可以忽略数组的长度并替换为...，例如：var nums = [...]int{1,2,3,4,5}，效果与上面一致。
- 通过将数组作为参数传递给len()函数，可以获取数组的长度；

## （三）、遍历数组：

1、普通数组：

```go
// 方式1
var arr1 [3]int
var arr2 = [4]int{1, 2, 3, 4}

func main() {
	// 方式2
	arr3 := [5]float64{1, 2, 3, 4, 5.5}
	// 方式3
	arr4 := [...]int{12, 3, 43, 54}
	fmt.Println(arr1)
	fmt.Println(arr2)
	fmt.Println(arr3)
	fmt.Println(arr4)
	// 遍历数组方式1
	for i := 0; i < len(arr4); i++ {
		fmt.Print(arr4[i], "\t")
	}
	fmt.Println()
	// 遍历数组方式2
	for _, value := range arr4 {
		fmt.Print(value, "\t")
	}
	//if arr2 == nil {
	//	fmt.Println("当前的arr是：", nil)
	//}
}
结果：
[0 0 0]
[1 2 3 4]
[1 2 3 4 5.5]
[12 3 43 54]
12	3	43	54	
12	3	43	54
如果判断数组为nil，编译器会报错：cannot convert nil to type [4]int；
```

2、多维数组：

语法格式：

var 变量名 [数组长度1]...[数组长度n] 数据类型，例如：

```go
var arr [10][5][4]int
```

实例：

```go
// 创建多维数组
a = [3][4]int{
    {0,1,2,3}   /*第一行索引为0*/
    {4,5,6,7}   /*第一行索引为1*/
    {8,9,10,11} /*第一行索引为2*/
}
// 访问多维数组
func main() {
	a := [3][4]int{
		{1, 2, 3, 4},
		{5, 6, 7, 8},
		{9, 10, 11, 12},
	}
	fmt.Println(a[2][3])
}
结果：12
a[2][3]访问的是a数组中的第三行的第四列的元素；

// 用for循环的方式访问多维数组
func main() {
	a := [3][4]int{
		{1, 2, 3, 4},
		{5, 6, 7, 8},
		{9, 10, 11, 12},
	}
	for i := 0; i < len(a); i++ {
		for j := 0; j < len(a[0]); j++ {
			fmt.Printf("a[%d][%d]=%d\n", i, j, a[i][j])
		}
	}
}
结果：
a[0][0]=1
a[0][1]=2
a[0][2]=3
a[0][3]=4
a[1][0]=5
a[1][1]=6
a[1][2]=7
a[1][3]=8
a[2][0]=9
a[2][1]=10
a[2][2]=11
a[2][3]=12
```

## （四）、数组是值类型：

1、数组是非引用（值类型）类型，这意味着当他们被分配一个新变量时，将把原始数组的副本分配给新变量，如果对新变量修改，则不会在原始数组中反映；

2、当数组传递给函数作为参数时，它们将通过值传递，而原始数组将保持不变；

3、实例：

```go
func main() {
	a := [...]string{"a", "b", "c", "d"}
	b := a
	b[0] = "x"
	fmt.Println("a:", a)
	fmt.Println("b:", b)
}
结果：
a: [a b c d]
b: [x b c d]
```

# 二、切片的用法：

## （一）、概念：

- 切片是对数组的抽象，由于数组的长度不可改变，在特定场景中这样的集合就不太适用，所以Go中提供了内置类型切片（动态数组）；
- 与数组相比切片的长度是不固定的，可以追加元素，追加时可能是切片容量变大；
- 切片本身没有任何数据，只是对现有数组的引用；
- 切片不需要设定长度，[]不用设置，相对自由；
- 概念上来说slice切片更像一个结构体，这个结构体包含三个元素：1、指针，指向数组中slice指定的开始位置，2、长度，即slice的长度，3、最大长度，即slice开始位置到数组最后位置的长度；

## （二）、切片的语法：

1、声明切片：

声明一个没有指定长度的数组来定义切片

- var 变量名 []数据类型
- 切片不需要指定长度
- 该声明方式，且未初始化的切片为空切片，默认为nil，长度为0；

2、使用make()函数来创建切片：

```go
//标准格式：
var slice []type = make([]type, len)
//短变量格式：
slice := make([]type, len)
//指定容量，其中capacity是可选参数：
slice := make([]type, len, cap)
//例子：
func main() {
	//var num = make([]int, 5)
    num := make([]int, 5)
	fmt.Printf("%T\n", num)
	fmt.Printf("len=%d,cap=%d,slice=%v\n", len(num), cap(num), num)
}
结果：
[]int
len=5,cap=5,slice=[0 0 0 0 0]
```

3、初始化切片：

（1）、直接初始化切片：

slice := []int{1,2,3}

（2）、通过数组截取来初始化切片：

数组：arr := [5]int{1,2,3,4,5}

- slice := arr[:]——切片中包含所有数组元素
- slice := arr[startindex:endindex]——将arr从下标startindex到endindex-1的元素创建为一个新的切片（前闭后开），长度为：endindex-startindex；
- slice := arr[startindex:]——缺省endindex时将表示一直到arr元素的最后一个
- slice := arr[:endindex]——缺省startindex时将表示从arr元素的第一个开始

（3）、通过切片截取来初始化切片：

可以通过设置上限和下限来设置截取切片[lower-bound:upper-bound]

实例：

```

```

